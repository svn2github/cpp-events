#ifndef __CPP_EVENTS__EVENTS_HPP
#define __CPP_EVENTS__EVENTS_HPP

#include "AbstractEvent.hpp"
#include "ConnectionEx.hpp"
#include "TypeTraits.hpp"

@@for(int i=0; i<8; i+=1)
@classArgs("template<", i, "> ")@class Event@i@;
@@next

@@for(int i=0; i<8; i+=1)
@classArgs("template<", i, "> ")@class EventRef@i@;
@@next

@@for(int i=0; i<8; i+=1)
@classArgs("template<", i, "> ")@class Event@i@ : public AbstractEvent
{
public:
	typedef Connection@i;selArgs("<", i, ">")@ ConnectionType;

	Event@i@() {}
	~Event@i@() {}

	inline EventRef@i;selArgs("<", i, ">")@ ref();

	void addConnection(ConnectionList * tracker, ConnectionType * conn)
	{
		AbstractEvent::addConnection(tracker, conn);
	}
	
	void fire(@funcArgs(i)@) const
	{
		FireLock lock(this);
		ConnectionsVector const & conns = lock.connections();
		for(ConnectionsVector::const_iterator it = conns.begin(); it != conns.end(); ++it)
		{
			static_cast<ConnectionType const *>(*it)->invoke(@callArgs(i)@);
		}
	}
};

@classArgs("template<", i, "> ")@class EventRef@i@ : public AbstractEventRef
{
public:
	typedef Event@i;selArgs("<", i, ">")@ EventType;
	typedef @if(i > 0) "typename " end@EventType::ConnectionType ConnectionType;

	explicit EventRef@i@(EventType * ev) : AbstractEventRef(ev) {}

	template<class T, class Y> void connect(ConnectionList * tracker, T * obj, void (Y::*pmf)(@funcArgs(i)@))
	{
		ConnectionType * conn = new ConnectionType(
			fastdelegate::MakeDelegate(obj, pmf)
		);
		addConnection(tracker, conn);
	}

	template<class T, class Y> void connect(ConnectionList * tracker, T const * obj, void (Y::*pmf)(@funcArgs(i)@) const)
	{
		ConnectionType * conn = new ConnectionType(
			fastdelegate::MakeDelegate(obj, pmf)
		);
		addConnection(tracker, conn);
	}

	template<class T, class Y> void connect(ConnectionList * tracker, T * obj, Y pmf)
	{
		detail::ArgList0 stored;
		connectEx(tracker, fastdelegate::MakeDelegate(obj, pmf), stored);
	}

@@for(int j=1; j<8; j+=1)
	template<class T, class Y, @list("class T%", 1, j)@> void connect(ConnectionList * tracker, T * obj, Y pmf, @list("T% x%", 1, j)@)
	{
@@for(int k=1; k<=j; k+=1)
		typedef typename StorageType<T@k@>::Type S@k@;
@@next
		detail::ArgList@j@<@list("S%", 1, j)@> stored(@list("x%", 1, j)@);
		connectEx(tracker, fastdelegate::MakeDelegate(obj, pmf), stored);
	}

@@next
@@for(int j=i; j<8; j+=1)
	@listx("template<%> ", "class T%", j)@void connectEvent(ConnectionList * tracker, Event@j;listx("<%>", "T%", j)@ * ev@iter(", T% x%", j-i)@)
	{
		connect(tracker, ev, &Event@j;listx("<%>", "T%", j)@::fire@iter(", x%", 0, j-i)@);
	}
@@next
private:
	void addConnection(ConnectionList * tracker, ConnectionType * conn)
	{
		static_cast<EventType*>(senderEvent())->addConnection(tracker, conn);
	}

	template<class DelegateClass, class StoredListClass> void connectEx(ConnectionList * tracker, DelegateClass const & deleg, StoredListClass const & stored)
	{
		ConnectionType * conn = new ConnectionEx@i@<@selArgs(i, ", ")@DelegateClass, StoredListClass>(
			deleg, stored
		);
		addConnection(tracker, conn);
	}
};

@classArgs("template<", i, "> ")@
inline EventRef@i;selArgs("<", i, ">")@ Event@i;selArgs("<", i, ">")@::ref()
{
	return EventRef@i;selArgs("<", i, ">")@(this);
}

@@next
#endif //__CPP_EVENTS__EVENTS_HPP